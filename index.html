<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asistente Creativo IA - Despliegue Rápido</title>
    <!-- Carga de React, ReactDOM y Babel (para interpretar JSX en el navegador) desde CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Carga de Tailwind CSS para estilos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configuración para usar Tailwind y la fuente Inter -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
          }
        }
      }
    </script>
    <style>
        /* Aseguramos que la fuente Inter se cargue */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
    </style>
</head>
<body class="font-sans">

    <!-- Contenedor donde React renderizará la aplicación -->
    <div id="root"></div>

    <!-- Script principal de la aplicación. Usamos type="text/babel" para que Babel lo compile. -->
    <script type="text/babel">
        // Importación manual de íconos de Lucide
        // Como no podemos usar 'import' en este entorno simple, definimos los componentes directamente
        const { useState, useCallback } = React;

        // Definiciones simplificadas de Lucide-React Icons (usando SVG simples para compatibilidad)
        const Icon = ({ children, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                {children}
            </svg>
        );

        const Lightbulb = (props) => (
            <Icon {...props}><path d="M15 14c.2-.8.8-1.4 1.6-2 .7-.6 1.3-1.4 1.6-2.3.4-.9.4-1.9-.2-2.7C17.5 4.9 16.6 4 15.6 4H8.4C7.4 4 6.5 4.9 6.2 5.7c-.6.8-.6 1.8-.2 2.7.3.9.9 1.7 1.6 2.3.8.6 1.4 1.2 1.6 2v4.8l-2 1.4c-.6.4-1 1.1-1 1.9 0 1.2.8 2.3 2.1 2.3h6c1.3 0 2.1-1.1 2.1-2.3 0-.8-.4-1.5-1-1.9l-2-1.4v-4.8z" /></Icon>
        );
        const Image = (props) => (
            <Icon {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></Icon>
        );
        const Send = (props) => (
            <Icon {...props}><path d="m22 2-7 20-4-9-9-4 20-7z" /><path d="M15 10l-4 4" /></Icon>
        );
        const Loader2 = (props) => (
            <Icon {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56" /></Icon>
        );
        const LinkIcon = (props) => (
            <Icon {...props}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" /><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" /></Icon>
        );
        const AlertTriangle = (props) => (
            <Icon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h18.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" /><path d="M12 9v4" /><path d="M12 17h.01" /></Icon>
        );
        const MessageSquare = (props) => (
            <Icon {...props}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></Icon>
        );
        const Sparkles = (props) => (
            <Icon {...props}><path d="M9.9 14.2l-.7.7a2.12 2.12 0 0 1-3 0l-.7-.7.7-.7a2.12 2.12 0 0 1 3 0z" /><path d="M15.4 12.8l.7-.7a2.12 2.12 0 0 0 0-3l-.7-.7-.7.7a2.12 2.12 0 0 0 0 3z" /><path d="M15.4 6.8l.7-.7a2.12 2.12 0 0 0 0-3l-.7-.7-.7.7a2.12 2.12 0 0 0 0 3z" /><path d="M9.9 1.4l-.7.7a2.12 2.12 0 0 0-3 0l-.7-.7.7-.7a2.12 2.12 0 0 0 3 0z" /></Icon>
        );
        const Volume2 = (props) => (
             <Icon {...props}><path d="M11 5L6 9H2v6h4l5 4V5z" /><path d="M17.3 10.3a8.6 8.6 0 0 1 0 3.4" /><path d="M21.9 8.1a13.3 13.3 0 0 1 0 7.8" /></Icon>
        );
        // Fin de las definiciones de íconos

        // Constantes de configuración de la API de Gemini (deben estar disponibles en el alcance global)
        const API_KEY = "AIzaSyDjV5WEjotg4CqGJHqleNj0brLqpE_D498"; 
        const TEXT_MODEL = "gemini-2.5-flash-preview-09-2025";
        const IMAGE_MODEL = "imagen-4.0-generate-001";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts"; 

        const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TEXT_MODEL}:generateContent?key=${API_KEY}`;
        const IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${IMAGE_MODEL}:predict?key=${API_KEY}`;
        const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${API_KEY}`;


        // --- Funciones de Utilidad para Conversión de Audio PCM a WAV ---
        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bytesPerSample = 2;
            const numSamples = pcm16.length;

            const buffer = new ArrayBuffer(44 + numSamples * bytesPerSample);
            const view = new DataView(buffer);

            // RIFF identifier
            writeString(view, 0, 'RIFF');
            // file length
            view.setUint32(4, 36 + numSamples * bytesPerSample, true);
            // RIFF type
            writeString(view, 8, 'WAVE');
            // format chunk identifier
            writeString(view, 12, 'fmt ');
            // format chunk length
            view.setUint32(16, 16, true);
            // sample format (1 for PCM)
            view.setUint16(20, 1, true);
            // number of channels
            view.setUint16(22, numChannels, true);
            // sample rate
            view.setUint32(24, sampleRate, true);
            // byte rate
            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
            // block align
            view.setUint16(32, numChannels * bytesPerSample, true);
            // bits per sample
            view.setUint16(34, 16, true);
            // data chunk identifier
            writeString(view, 36, 'data');
            // data chunk length
            view.setUint32(40, numSamples * bytesPerSample, true);

            // PCM data
            let offset = 44;
            for (let i = 0; i < numSamples; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        };


        // Hook para manejar la configuración de la UI y las interacciones
        const useAppLogic = () => {
            const [prompt, setPrompt] = useState('');
            const [responseText, setResponseText] = useState(null);
            const [imageResult, setImageResult] = useState(null);
            const [sources, setSources] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [isTtsLoading, setIsTtsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [mode, setMode] = useState('text'); 

            // Función para manejar la lógica de reintento con retroceso exponencial
            const fetchWithRetry = useCallback(async (url, options, retries = 3) => {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (response.ok) {
                            return response;
                        }
                        throw new Error(`Error HTTP: ${response.status} ${response.statusText}`);
                    } catch (e) {
                        console.error(`Intento ${i + 1} fallido:`, e);
                        if (i < retries - 1) {
                            const delay = Math.pow(2, i) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            throw new Error(`Fallo en la conexión después de ${retries} intentos: ${e.message}`);
                        }
                    }
                }
            }, []);

            // Función para manejar la generación de texto
            const handleGenerateText = useCallback(async (userPrompt) => {
                setIsLoading(true);
                setError(null);
                setResponseText(null);
                setSources([]);

                try {
                    const systemPrompt = "Eres un asistente de inteligencia artificial útil y conciso. Responde a la pregunta del usuario utilizando la información más actualizada posible, con un tono informativo y amigable. Si la respuesta requiere información del mundo real, usa la herramienta de búsqueda de Google. Presenta la respuesta en formato Markdown.";

                    const payload = {
                        contents: [{ parts: [{ text: userPrompt }] }],
                        tools: [{ "google_search": {} }],
                        systemInstruction: {
                            parts: [{ text: systemPrompt }]
                        },
                    };

                    const response = await fetchWithRetry(TEXT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        setResponseText(text);

                        let newSources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            newSources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title);
                        }
                        setSources(newSources);

                    } else if (result.error) {
                        throw new Error(result.error.message);
                    } else {
                        throw new Error("No se pudo obtener una respuesta válida del modelo de texto.");
                    }

                } catch (e) {
                    console.error("Error al generar texto:", e);
                    setError(`Error al procesar la pregunta: ${e.message}. Por favor, inténtalo de nuevo.`);
                } finally {
                    setIsLoading(false);
                }
            }, [fetchWithRetry]);

            // Función para manejar la generación de audio (TTS)
            const handleGenerateTTS = useCallback(async (textToSpeak) => {
                setIsTtsLoading(true);
                setError(null);

                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Di esto de forma informativa y amigable: ${textToSpeak}` }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Kore" } 
                                }
                            }
                        },
                    };

                    const response = await fetchWithRetry(TTS_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                        
                        const pcmBuffer = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmBuffer);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();

                        audio.onended = () => URL.revokeObjectURL(audioUrl);

                    } else {
                        throw new Error("No se pudo obtener datos de audio o el formato no es compatible.");
                    }

                } catch (e) {
                    console.error("Error al generar audio:", e);
                    setError(`Error al generar audio: ${e.message}.`);
                } finally {
                    setIsTtsLoading(false);
                }
            }, [fetchWithRetry]);

            // Función para manejar la generación de imágenes
            const handleGenerateImage = useCallback(async (userPrompt) => {
                setIsLoading(true);
                setError(null);
                setImageResult(null);

                try {
                    const payload = { 
                        instances: [{ prompt: userPrompt }], 
                        parameters: { "sampleCount": 1 } 
                    };

                    const response = await fetchWithRetry(IMAGE_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        const base64Data = result.predictions[0].bytesBase64Encoded;
                        const imageUrl = `data:image/png;base64,${base64Data}`;
                        setImageResult(imageUrl);
                    } else if (result.error) {
                        throw new Error(result.error.message);
                    } else {
                        throw new Error("No se pudo generar la imagen. Inténtalo con una descripción diferente.");
                    }
                } catch (e) {
                    console.error("Error al generar imagen:", e);
                    setError(`Error al generar la imagen: ${e.message}. Asegúrate de que la descripción sea clara y adecuada.`);
                } finally {
                    setIsLoading(false);
                }
            }, [fetchWithRetry]);

            // Función principal de envío
            const handleSubmit = useCallback(() => {
                if (!prompt.trim()) return;

                if (mode === 'text') {
                    handleGenerateText(prompt.trim());
                } else {
                    handleGenerateImage(prompt.trim());
                }
            }, [prompt, mode, handleGenerateText, handleGenerateImage]);

            // Restablecer resultados al cambiar el modo
            const switchMode = useCallback((newMode) => {
                if (newMode !== mode) {
                    setMode(newMode);
                    setResponseText(null);
                    setImageResult(null);
                    setSources([]);
                    setError(null);
                    setPrompt('');
                    setIsLoading(false);
                    setIsTtsLoading(false);
                }
            }, [mode]);

            return {
                prompt, setPrompt,
                responseText, imageResult, sources,
                isLoading, isTtsLoading, error, mode,
                switchMode, handleSubmit, handleGenerateTTS,
                TEXT_MODEL, IMAGE_MODEL, TTS_MODEL
            };
        };

        // Componente principal de la aplicación
        const App = () => {
            const {
                prompt, setPrompt,
                responseText, imageResult, sources,
                isLoading, isTtsLoading, error, mode,
                switchMode, handleSubmit, handleGenerateTTS,
                TEXT_MODEL, IMAGE_MODEL, TTS_MODEL
            } = useAppLogic();

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSubmit();
                }
            };
            
            const cleanMarkdownForTts = (text) => {
                if (!text) return "";
                let cleanText = text.replace(/(\*\*|__|\*|#|\n)/g, ' ');
                cleanText = cleanText.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
                cleanText = cleanText.replace(/\s\s+/g, ' ').trim();
                return cleanText;
            };

            const ModeButton = ({ currentMode, icon: Icon, label, modelName }) => (
                <button
                    onClick={() => switchMode(currentMode)}
                    className={`flex items-center space-x-2 p-3 text-sm font-semibold transition-all duration-300 rounded-lg ${
                        mode === currentMode
                        ? 'bg-blue-600 text-white shadow-lg'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    } w-full justify-center md:w-auto`}
                >
                    <Icon className="w-5 h-5" />
                    <span>{label}</span>
                    <span className="text-xs font-normal opacity-70">({modelName.split('-')[1].toUpperCase()})</span>
                </button>
            );

            return (
                <div className="min-h-screen bg-gray-50 flex flex-col items-center p-4 sm:p-8 font-sans">
                    <header className="w-full max-w-4xl text-center mb-8">
                        <h1 className="text-4xl font-extrabold text-gray-900 flex items-center justify-center space-x-2">
                            <Sparkles className="w-8 h-8 text-blue-600" />
                            <span>Asistente Creativo IA</span>
                        </h1>
                        <p className="text-gray-500 mt-2">
                            Una herramienta versátil para obtener respuestas, generar imágenes y ahora ¡escuchar las respuestas!
                        </p>
                    </header>

                    {/* Selector de Modo */}
                    <div className="w-full max-w-4xl flex flex-col md:flex-row space-y-3 md:space-y-0 md:space-x-4 mb-6 p-4 bg-white rounded-xl shadow-md">
                        <ModeButton
                            currentMode="text"
                            icon={MessageSquare}
                            label="Modo Pregunta"
                            modelName={TEXT_MODEL}
                        />
                        <ModeButton
                            currentMode="image"
                            icon={Image}
                            label="Modo Imagen"
                            modelName={IMAGE_MODEL}
                        />
                    </div>

                    {/* Área de Entrada (Prompt) */}
                    <div className="w-full max-w-4xl bg-white rounded-xl shadow-lg p-4 mb-8">
                        <div className="flex items-center border border-gray-300 rounded-lg focus-within:ring-2 focus-within:ring-blue-500 transition-shadow">
                            <div className="p-3 text-gray-500">
                                {mode === 'text' ? <Lightbulb className="w-6 h-6" /> : <Image className="w-6 h-6" />}
                            </div>
                            <textarea
                                className="flex-grow p-3 resize-none outline-none text-gray-800 placeholder-gray-400 h-24 sm:h-20"
                                placeholder={
                                    mode === 'text'
                                    ? 'Escribe tu pregunta (ej: ¿Cómo funciona la energía solar?)...'
                                    : 'Describe la imagen que quieres generar (ej: Un perro astronauta flotando en el espacio, estilo arte digital 4k)...'
                                }
                                value={prompt}
                                onChange={(e) => setPrompt(e.target.value)}
                                onKeyDown={handleKeyDown}
                                disabled={isLoading || isTtsLoading}
                            />
                            <button
                                onClick={handleSubmit}
                                disabled={isLoading || isTtsLoading || !prompt.trim()}
                                className={`p-4 rounded-r-lg h-full transition-colors duration-200 ${
                                    isLoading || isTtsLoading || !prompt.trim()
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : 'bg-blue-600 hover:bg-blue-700 text-white'
                                }`}
                                aria-label="Enviar"
                            >
                                {isLoading ? <Loader2 className="w-6 h-6 animate-spin" /> : <Send className="w-6 h-6" />}
                            </button>
                        </div>
                    </div>

                    {/* Área de Resultados */}
                    <div className="w-full max-w-4xl">
                        {error && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded mb-6 flex items-start space-x-2">
                                <AlertTriangle className="w-5 h-5 mt-1 flex-shrink-0" />
                                <p className="font-medium">{error}</p>
                            </div>
                        )}

                        {(isLoading || isTtsLoading) && (
                            <div className="flex flex-col items-center justify-center p-12 bg-white rounded-xl shadow-md">
                                <Loader2 className="w-8 h-8 text-blue-600 animate-spin mb-3" />
                                <p className="text-gray-600 font-medium">
                                    {isLoading ? (
                                        mode === 'text' ? 'Buscando y generando respuesta...' : 'Generando tu imagen (puede tardar unos segundos)...'
                                    ) : (
                                        'Convirtiendo texto a voz...'
                                    )}
                                </p>
                            </div>
                        )}

                        {/* Mostrar Resultado de Texto */}
                        {mode === 'text' && responseText && (
                            <div className="bg-gradient-to-br from-purple-50 to-rose-50 p-6 rounded-xl shadow-xl border border-rose-300">
                                <div className="flex justify-between items-center mb-4 border-b pb-2 border-rose-300">
                                    <h2 className="text-2xl font-bold text-gray-800 flex items-center space-x-2">
                                        <MessageSquare className="w-6 h-6 text-blue-600" />
                                        <span>Respuesta Generada</span>
                                    </h2>
                                    <button
                                        onClick={() => handleGenerateTTS(cleanMarkdownForTts(responseText))}
                                        disabled={isTtsLoading}
                                        className={`flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                            isTtsLoading 
                                                ? 'bg-gray-400 text-white cursor-not-allowed' 
                                                : 'bg-green-500 hover:bg-green-600 text-white shadow-md'
                                        }`}
                                    >
                                        <Sparkles className="w-4 h-4" />
                                        {isTtsLoading ? (
                                            <Loader2 className="w-4 h-4 animate-spin" />
                                        ) : (
                                            <Volume2 className="w-4 h-4" />
                                        )}
                                        <span>{isTtsLoading ? 'Cargando...' : 'Escuchar Respuesta'}</span>
                                    </button>
                                </div>
                                
                                <div 
                                    dangerouslySetInnerHTML={{ __html: responseText }} 
                                    className="text-gray-800 text-lg leading-relaxed
                                    /* Estilos para eliminar viñetas (bullet points) de listas */
                                    [&_ul]:list-none [&_ul]:p-0 [&_ul]:m-0 
                                    [&_ol]:list-none [&_ol]:p-0 [&_ol]:m-0 
                                    [&_li]:ml-0 [&_li]:pl-0 [&_li]:mt-2 
                                    [&_p]:mb-4"
                                ></div>

                                {sources.length > 0 && (
                                    <div className="mt-6 pt-4 border-t border-rose-300">
                                        <p className="text-sm font-semibold text-gray-600 mb-2">Fuentes de Verificación (Grounding):</p>
                                        <ul className="space-y-1 text-sm text-blue-700 list-none pl-0">
                                            {sources.map((source, index) => (
                                                <li key={index} className="flex items-start">
                                                    <LinkIcon className="w-4 h-4 mr-2 mt-1 flex-shrink-0" />
                                                    <a
                                                        href={source.uri}
                                                        target="_blank"
                                                        rel="noopener noreferrer"
                                                        className="hover:underline"
                                                    >
                                                        {source.title || source.uri}
                                                    </a>
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Mostrar Resultado de Imagen */}
                        {mode === 'image' && imageResult && (
                            <div className="bg-white p-6 rounded-xl shadow-lg">
                                <h2 className="text-2xl font-bold text-gray-800 mb-4 border-b pb-2 flex items-center space-x-2">
                                    <Image className="w-6 h-6 text-blue-600" />
                                    <span>Imagen Generada</span>
                                </h2>
                                <div className="flex justify-center items-center bg-gray-100 rounded-lg p-4">
                                    <img
                                        src={imageResult}
                                        alt={prompt}
                                        className="max-w-full h-auto rounded-lg shadow-xl border-4 border-gray-200"
                                    />
                                </div>
                                <p className="mt-4 text-sm text-gray-500 italic">
                                    Prompt utilizado: "{prompt}"
                                </p>
                            </div>
                        )}

                        {/* Mensaje de bienvenida/instrucción inicial */}
                        {!isLoading && !responseText && !imageResult && !error && (
                            <div className="bg-white p-8 rounded-xl shadow-lg text-center">
                                <Sparkles className="w-12 h-12 text-blue-500 mx-auto mb-4" />
                                <h2 className="text-xl font-bold text-gray-800 mb-2">¡Comienza tu Consulta!</h2>
                                <p className="text-gray-600">
                                    Selecciona el **Modo Pregunta** para obtener información o el **Modo Imagen** para generar arte a partir de una descripción.
                                </p>
                            </div>
                        )}
                    </div>

                    <footer className="w-full max-w-4xl text-center mt-12 pt-4 border-t border-gray-200 text-sm text-gray-500">
                        <p>Impulsado por Gemini ({TEXT_MODEL.split('-')[1].toUpperCase()} para texto, {TTS_MODEL.split('-')[1].toUpperCase()} para voz) e Imagen ({IMAGE_MODEL.split('-')[0].toUpperCase()} para imágenes).</p>
                        <p>Usa la tecla Enter para enviar tu solicitud.</p>
                    </footer>
                </div>
            );
        };

        // Renderizar la aplicación en el DOM
        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>